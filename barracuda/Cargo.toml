[package]
name = "hotspring-barracuda"
version = "0.6.0"
edition = "2021"
description = "Nuclear EOS + GPU MD validation for BarraCUDA — L1/L2/L3 physics, Yukawa OCP, lattice QCD, spectral theory, typed errors, full Result propagation, provenance, capability-based discovery"
license = "AGPL-3.0-only"

[workspace]

# ── Lint configuration (applies to all targets: lib + bins) ──
# Physics code justifies certain clippy patterns. Each allow is annotated.
[workspace.lints.clippy]
pedantic = { level = "warn", priority = -1 }
nursery = { level = "warn", priority = -1 }

# Physics casts: usize↔f64 is endemic in computational physics (particle
# counts, grid indices, accumulator conversions). These are intentional.
cast_precision_loss = "allow"
cast_possible_truncation = "allow"
cast_sign_loss = "allow"
cast_possible_wrap = "allow"
cast_lossless = "allow"

# Physics naming: vx/vy/vz, rho_p/rho_n, r/k/q/E/V are standard notation.
similar_names = "allow"
many_single_char_names = "allow"

# Physics notation in doc comments (e.g. χ², κ, Γ, SU(3)).
doc_markdown = "allow"

# Physics constants (e.g. 0.520_499_877_8 for erf(0.5)) are clearer unseparated.
unreadable_literal = "allow"

# Scientific formulas: a*b + c is often clearer than mul_add in physics context.
suboptimal_flops = "allow"
imprecise_flops = "allow"

# Physics APIs: HFB solvers genuinely need 10+ parameters; these are not design smells.
too_many_arguments = "allow"
too_many_lines = "allow"
cognitive_complexity = "allow"

# Ergonomic allows for physics library API style.
module_name_repetitions = "allow"
must_use_candidate = "allow"
return_self_not_must_use = "allow"
missing_panics_doc = "allow"
missing_errors_doc = "allow"
use_self = "allow"
redundant_else = "allow"
struct_field_names = "allow"
items_after_statements = "allow"
option_if_let_else = "allow"
type_complexity = "allow"
implicit_hasher = "allow"
needless_pass_by_value = "allow"
inline_always = "allow"
significant_drop_tightening = "allow"

# RNG helpers and builders are clearer as non-const — wrapping_mul/rotate_left
# chains in const context add noise without benefit.
missing_const_for_fn = "allow"

# Shared-code-in-branches: physics validation binaries intentionally have
# parallel if/else blocks that include common print preambles for clarity.
branches_sharing_code = "allow"

# pub(crate) on items inside a pub(crate) module is technically redundant but
# signals intent for cross-module GPU type sharing within the crate.
redundant_pub_crate = "allow"

[lints]
workspace = true

[features]
gpu_energy = []

[dependencies]
# BarraCUDA: All scientific computing from the library
barracuda = { path = "../../phase1/toadstool/crates/barracuda" }

# Data loading
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Parallelism for L2 HFB
rayon = "1.8"

# Byte casting for GPU uniform buffers
bytemuck = { version = "1.14", features = ["derive"] }

# Async runtime for GPU validation (validate_md)
tokio = { version = "1.35", features = ["rt-multi-thread", "macros"] }

# GPU compute (wgpu for SHADER_F64 FP64 science compute)
# Must match barracuda's wgpu version (22) to avoid type conflicts.
wgpu = { version = "22", default-features = false, features = [
    "wgsl",
    "vulkan-portability",
] }

# ── L1 validation (NMP-constrained, Pareto sweep, multi-seed) ──────
[[bin]]
name = "nuclear_eos_l1_ref"
path = "src/bin/nuclear_eos_l1_ref.rs"

# ── L2 validation (L1-seeded DirectSampler, HFB) ───────────────────
[[bin]]
name = "nuclear_eos_l2_ref"
path = "src/bin/nuclear_eos_l2_ref.rs"

# ── L2 GPU-batched HFB (BatchedEighGpu from toadstool) ─────────
[[bin]]
name = "nuclear_eos_l2_gpu"
path = "src/bin/nuclear_eos_l2_gpu.rs"

# ── L2 heterogeneous pipeline (cascade: NMP → L1 → classifier → HFB)
[[bin]]
name = "nuclear_eos_l2_hetero"
path = "src/bin/nuclear_eos_l2_hetero.rs"

# ── BarraCUDA library validation suites ─────────────────────────────
[[bin]]
name = "validate_special_functions"
path = "src/bin/validate_special_functions.rs"

[[bin]]
name = "validate_linalg"
path = "src/bin/validate_linalg.rs"

[[bin]]
name = "validate_optimizers"
path = "src/bin/validate_optimizers.rs"

[[bin]]
name = "validate_md"
path = "src/bin/validate_md.rs"

# ── GPU FP64 validation (L1 + L2 on RTX 4070 via SHADER_F64) ────
[[bin]]
name = "nuclear_eos_gpu"
path = "src/bin/nuclear_eos_gpu.rs"

# ── HFB physics verification (Rust vs Python) ────────────────────
[[bin]]
name = "verify_hfb"
path = "src/bin/verify_hfb.rs"

# ── Sarkas GPU: Yukawa OCP molecular dynamics on consumer GPU ────
[[bin]]
name = "sarkas_gpu"
path = "src/bin/sarkas_gpu.rs"

# ── f64 builtin test: check if native sqrt/exp work on f64 ────
[[bin]]
name = "f64_builtin_test"
path = "src/bin/f64_builtin_test.rs"

# ── PPPM Coulomb validation (toadstool PppmGpu, kappa=0) ────
[[bin]]
name = "validate_pppm"
path = "src/bin/validate_pppm.rs"

# ── Cell-list force diagnostic: compare all-pairs vs cell-list kernels ────
[[bin]]
name = "celllist_diag"
path = "src/bin/celllist_diag.rs"

# ── BarraCUDA full-pipeline validation (ops → Yukawa OCP → energy conservation) ──
[[bin]]
name = "validate_barracuda_pipeline"
path = "src/bin/validate_barracuda_pipeline.rs"

# ── BarraCUDA HFB pipeline validation (BCS bisection + eigensolve) ──
[[bin]]
name = "validate_barracuda_hfb"
path = "src/bin/validate_barracuda_hfb.rs"

# ── L3 deformed HFB (CPU Rayon) ───────────────────────────────────
[[bin]]
name = "nuclear_eos_l3_ref"
path = "src/bin/nuclear_eos_l3_ref.rs"

# ── L3 deformed HFB (GPU-resident — all physics on GPU) ──────────
[[bin]]
name = "nuclear_eos_l3_gpu"
path = "src/bin/nuclear_eos_l3_gpu.rs"

# ── Nuclear EOS validation: pure Rust replication of Python controls ──
[[bin]]
name = "validate_nuclear_eos"
path = "src/bin/validate_nuclear_eos.rs"

# ── Meta-validator: runs all validation suites ─────────────────────────
[[bin]]
name = "validate_all"
path = "src/bin/validate_all.rs"

# ── NVK workgroup-size diagnostic ──────────────────────────────────────
[[bin]]
name = "bench_wgsize_nvk"
path = "src/bin/bench_wgsize_nvk.rs"

# ── Multi-GPU benchmark ───────────────────────────────────────────
[[bin]]
name = "bench_multi_gpu"
path = "src/bin/bench_multi_gpu.rs"

# ── GPU FP64 throughput benchmark ─────────────────────────────────
[[bin]]
name = "bench_gpu_fp64"
path = "src/bin/bench_gpu_fp64.rs"

# ── Transport coefficient validation (Stanton & Murillo 2016) ──────
[[bin]]
name = "validate_transport"
path = "src/bin/validate_transport.rs"

# ── CPU/GPU parity: same algorithm, same initial conditions, different chip ──
[[bin]]
name = "validate_cpu_gpu_parity"
path = "src/bin/validate_cpu_gpu_parity.rs"

# ── CPU vs GPU N-scaling benchmark (fp64 throughput + cost analysis) ──
[[bin]]
name = "bench_cpu_gpu_scaling"
path = "src/bin/bench_cpu_gpu_scaling.rs"

# ── NAK-optimized eigensolve validation (correctness + perf vs baseline) ──
[[bin]]
name = "validate_nak_eigensolve"
path = "src/bin/validate_nak_eigensolve.rs"

# ── Paper 5: Stanton-Murillo transport coefficient validation ──
[[bin]]
name = "validate_stanton_murillo"
path = "src/bin/validate_stanton_murillo.rs"

# ── Paper 7: HotQCD EOS table validation (Bazavov bridge) ──
[[bin]]
name = "validate_hotqcd_eos"
path = "src/bin/validate_hotqcd_eos.rs"

# ── Paper 6: Screened Coulomb bound states (Murillo & Weisheit 1998) ──
[[bin]]
name = "validate_screened_coulomb"
path = "src/bin/validate_screened_coulomb.rs"

# ── Paper 6: Rust vs Python performance benchmark ──
[[bin]]
name = "bench_screened_coulomb"
path = "src/bin/bench_screened_coulomb.rs"

# ── Paper 8: Pure gauge SU(3) lattice QCD on consumer GPU ──
[[bin]]
name = "validate_pure_gauge"
path = "src/bin/validate_pure_gauge.rs"

[[bin]]
name = "validate_reservoir_transport"
path = "src/bin/validate_reservoir_transport.rs"

[[bin]]
name = "validate_npu_quantization"
path = "src/bin/validate_npu_quantization.rs"

[[bin]]
name = "validate_npu_beyond_sdk"
path = "src/bin/validate_npu_beyond_sdk.rs"

[[bin]]
name = "validate_npu_pipeline"
path = "src/bin/validate_npu_pipeline.rs"

[[bin]]
name = "validate_lattice_npu"
path = "src/bin/validate_lattice_npu.rs"

[[bin]]
name = "validate_hetero_monitor"
path = "src/bin/validate_hetero_monitor.rs"

[[bin]]
name = "validate_spectral"
path = "src/bin/validate_spectral.rs"

[[bin]]
name = "validate_lanczos"
path = "src/bin/validate_lanczos.rs"

[[bin]]
name = "validate_anderson_3d"
path = "src/bin/validate_anderson_3d.rs"

[[bin]]
name = "validate_hofstadter"
path = "src/bin/validate_hofstadter.rs"

# ── GPU SpMV: CSR sparse matrix-vector product on GPU (spectral theory P1) ──
[[bin]]
name = "validate_gpu_spmv"
path = "src/bin/validate_gpu_spmv.rs"

# ── GPU Lanczos: eigensolve via GPU SpMV inner loop ──
[[bin]]
name = "validate_gpu_lanczos"
path = "src/bin/validate_gpu_lanczos.rs"

# ── GPU Dirac: staggered Dirac operator on GPU (Papers 9-12) ──
[[bin]]
name = "validate_gpu_dirac"
path = "src/bin/validate_gpu_dirac.rs"

# ── GPU CG: conjugate gradient D†D on GPU (Papers 9-12 complete) ──
[[bin]]
name = "validate_gpu_cg"
path = "src/bin/validate_gpu_cg.rs"

# ── Lattice QCD CG benchmark: Rust CPU vs Python baseline ──
[[bin]]
name = "bench_lattice_cg"
path = "src/bin/bench_lattice_cg.rs"

# ── Pure GPU lattice QCD: HMC + GPU CG on thermalized configs ──
[[bin]]
name = "validate_pure_gpu_qcd"
path = "src/bin/validate_pure_gpu_qcd.rs"

# ── Paper 13: Abelian Higgs (1+1)D U(1)+scalar field theory ──
[[bin]]
name = "validate_abelian_higgs"
path = "src/bin/validate_abelian_higgs.rs"

# ── Lattice QCD scaling: GPU CG at production lattice sizes ──
[[bin]]
name = "bench_lattice_scaling"
path = "src/bin/bench_lattice_scaling.rs"
